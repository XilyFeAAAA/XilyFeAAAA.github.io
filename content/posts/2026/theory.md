---
title: "数论"
date: '2026-01-12T11:31:48+08:00'
featuredImage: "https://raw.githubusercontent.com/XilyFeAAAA/ImgRepository/main/img/2026112.png"
authors: [Xilyfe]
series: ["算法分析与设计"]
tags: ["算法", "数论"]
---
## 最大公约数

### 欧几里得算法

#### 代码

```python
def gcd(a, b):
	if b == 0: return a
	else: return gcd(b, a % b)
```

时间复杂度为：**O(log(min(a, b)))** 或 **O(log(max(a, b)))**

#### 证明

我们首先假设有两个数 $a$ 和 $b$，其中 $a$ 是不小于 $b$ 的数，记 $a$ 被 $b$ 除的余数为 $r$，那么 $a$ 可以写成这样的形式：

$$
a = bq + r
$$

其中 $q$ 是整数。现在假设 $a$ 和 $b$ 的一个约数为 $u$，那么 $a$ 和 $b$ 都能被 $u$ 整除，即


\[
\begin{aligned}
a &=su \\
b &=tu
\end{aligned}
\]



$s$ 和 $t$ 都是整数。这样可以得出：

$$
r = a - bq = su - (tu)q = (s - tq)u
$$

所以 $r$ 也能被 $u$ 整除，我们能得到一般规律如下：

> $a$ 和 $b$ 的约数也整除它们的余数 $r$，所以 $a$ 和 $b$ 的任一约数同时也是 $b$ 和 $r$ 的约数。 

反过来可以得出：

> $b$ 和 $r$ 的任一约数同时也是 $a$ 和 $b$ 的约数。

因此，我们可以推出：$a$ 和 $b$ 的约数的集合，全等于 $b$ 和 $r$ 的约数的集合，所以 $a$ 和 $b$ 的最大公约数，就是 $b$ 和 $r$ 的最大公约数。

$$
\text{gcd}(a,b) = \text{gcd}(b, r)
$$

根据递推性质，我们可以不断减小 $b$ 使得公式变为 $gcd(x,0)$，结果就是 x。

### 扩展欧几里得算法

#### 代码

```python
def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x1, y1 = extended_gcd(b, a % b)
    x = y1
    y = x1 - (a / b) * y1
    return gcd, x, y
```

#### 证明

欧几里得算法产生如下除法序列： 

1. $a = q₁ b + r₁ (0 ≤ r₁ < b)$ 
2. $b = q₂ r₁ + r₂ (0 ≤ r₂ < r₁)$
3. $r₁ = q₃ r₂ + r₃ (0 ≤ r₃ < r₂)$
4. ... 
5. $r_{k-2} = q_k r_{k-1} + r_k$
6. $r_{k-1} = q_{k+1} r_k + 0$

则 $gcd(a, b) = r_k$ 最后一个非零余数。现在**从后往前回代**，证明 $r_k$ 可以表示为 $a$ 和 $b$ 的线性组合。

1. 从倒数第二步： $r_k = r_{k-2} - q_k r_{k-1}$ （这是 $r_{k-2}$ 和 $r_{k-1}$ 的线性组合）
2. 将 $r_{k-1}$ 代入上一式： $r_{k-1} = r_{k-3} - q_{k-1} r_{k-2}$ → $r_k = r_{k-2} - q_k (r_{k-3} - q_{k-1} r_{k-2}) = (1 + q_k q_{k-1}) r_{k-2} - q_k r_{k-3}$
3. 继续回代，最终所有余数都会被表达为更早的余数，直至：
    - $r₁$ 用 $a$ 和 $b$ 表示：$r₁ = a - q₁ b$
    - $b$ 用 $b$ 表示（自身）

最终，$r_k$（即 gcd）将被表达为 $a$ 和 $b$ 的整数系数线性组合： **gcd(a, b) = r_k = a x + b y**

## 线性模方程

### 问题背景

在模 n 的世界里，只剩下 n 个“基本元素” ${0, 1, 2, …, n−1}$，每一个元素实际上代表一个无限集合 $[k] = { k + tn | t ∈ ℤ }$。例如在模 7 的世界里：

- 0 代表 $\{…, −14, −7, 0, 7, 14, …\}$
- 3 代表 $\{…, −11, −4, 3, 10, 17, …\}$

因此我们可以写出 $7 \equiv 12 (\text{mod} 5)$，因为它们对 5 的余数相同。而线性模方程解决的就是：

$$
ax \equiv b (mod \,n)
$$

其中 a, b, n 是已知整数，n > 0，x 是未知整数，我们要求的就是 **x 在模 n 意义下的解**。但是在模 n 的世界里，**除法并不天然存在**。所以线性模方程解决的是：

> **在模运算体系中，什么时候可以做“除法”，以及怎么做。**

### 除法存在的条件

假设 $d=\text{gcd}(a, n)$，当且仅当 $d \, | \, b$（整除） 时，方程 $ax \equiv b (mod \, n)$ 有解，并且在模意义下存在 d 个不同的解。

### 怎么做

```python
def linear_mod(a, b, n):
	d, x, y = gcd_extened(a, b)
	if d % b: return -1
	x0 = (x * b / d) % n
	for i in range(n):
		print(x0 + i * n / d) % n
```
> [!NOTE]
> 感觉不考，具体原理看不懂

## 中国余数定理

中国余数定理主要解决**一组线性同余方程组的求解问题**，即： 给定多个模数和对应的余数，求一个整数 x 使得它同时满足所有这些同余条件。简单地说就是**线性模方程组求解**。

$$
\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\vdots \\
x \equiv a_k \pmod{m_k}
\end{cases}
$$

假设 $m_1,m_2,...,m_k$ 两两互质，那么方程组在模 $M=m_1m_2...m_k$ 空间下有唯一解。

> [!NOTE]
> 这里的唯一解并不是说 x 只有唯一值 ，而是说在模 M 空间下 x 唯一。

解方程组步骤：
1. 计算 $M$ 和 $M_i$
	1. $M=m_1m_2...m_k$
	2. $M_i=M / m_i$
2. 计算 $M_i$ 在模 $m_i$ 下的乘法逆元 $M_i^{-1}$ ，$M_i · M_i^{-1} ≡ 1 (mod \, m_i)$ 
3. 计算 $c_i=M_i \times (M_i^{-1} \mod n_i)$ 
4. $x = \sum{c_i \times a_i (mod \, M)}$ 

---

```
例：找出被9,8,7除时，余数分别为1,2,3的x，怎么写成同余方程组
```
